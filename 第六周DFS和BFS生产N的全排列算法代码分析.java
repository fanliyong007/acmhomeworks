import java.util.Scanner;public class DFSpermulation {	int n=0;	int[] a=new int[10];	int[] b=new int[10];	public void dfs(int step)//当前在第几个位置	{		if(step==n+1)//前n个数字已经放好		{			for(int i=1;i<=n;i++)			{				System.out.print(a[i]);			}			System.out.println();			return;		}		//每次都从1-n 逐步尝试		for(int i=1;i<=n;i++)		{			if(b[i]==0)//这个数字是否用过			{				a[step]=i;//没用过，这个位置就放i				b[i]=1;//标示i已经被用过，防止再用				dfs(step+1);//放好这个数字后，下一个数字，展开是一棵树				b[i]=0;//回溯，当满足一种全排列后，下一个尝试						}		}		return;	}	public static void main(String[] args) 	{		DFSpermulation dfs=new DFSpermulation();		int n=0;		Scanner scan=new Scanner(System.in);		n=scan.nextInt();		dfs.n=n;		dfs.dfs(1);	}}3------step=1发现b[1]==0,可以存放,a[1]=1 标记为1，递归step+1=2------step=2发现b[2]==0,可以存放,a[2]=2 标记为1，递归step+1=3------step=3发现b[3]==0,可以存放,a[3]=3 标记为1，递归step+1=4------step=4step=4 找到全部排列打印：123回退--------------------------b[3]回退--------------------------b[2]发现b[3]==0,可以存放,a[2]=3 标记为1，递归step+1=3------step=3发现b[2]==0,可以存放,a[3]=2 标记为1，递归step+1=4------step=4step=4 找到全部排列打印：132回退--------------------------b[2]回退--------------------------b[3]回退--------------------------b[1]发现b[2]==0,可以存放,a[1]=2 标记为1，递归step+1=2------step=2发现b[1]==0,可以存放,a[2]=1 标记为1，递归step+1=3------step=3发现b[3]==0,可以存放,a[3]=3 标记为1，递归step+1=4------step=4step=4 找到全部排列打印：213回退--------------------------b[3]回退--------------------------b[1]发现b[3]==0,可以存放,a[2]=3 标记为1，递归step+1=3------step=3发现b[1]==0,可以存放,a[3]=1 标记为1，递归step+1=4------step=4step=4 找到全部排列打印：231回退--------------------------b[1]回退--------------------------b[3]回退--------------------------b[2]发现b[3]==0,可以存放,a[1]=3 标记为1，递归step+1=2------step=2发现b[1]==0,可以存放,a[2]=1 标记为1，递归step+1=3------step=3发现b[2]==0,可以存放,a[3]=2 标记为1，递归step+1=4------step=4step=4 找到全部排列打印：312回退--------------------------b[2]回退--------------------------b[1]发现b[2]==0,可以存放,a[2]=2 标记为1，递归step+1=3------step=3发现b[1]==0,可以存放,a[3]=1 标记为1，递归step+1=4------step=4step=4 找到全部排列打印：321回退--------------------------b[1]回退--------------------------b[2]回退--------------------------b[3]4123412431324134214231432213421432314234124132431312431423214324134123421412341324213423143124321共找到244123412431324134214231432213421432314234124132431312431423214324134123421412341324213423143124321共生产：24干净的BFSimport java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class BFSpermulation {	//offer(1),poll(),isEmpey();	Queue<String> que=new LinkedList<String>();	public void bfs(int n)	{		String qhead="";//队列的首		int s=0;//产生的记录个数		String u="";//记录产生的排列		for(int i=1;i<=n;i++)		{			que.offer(String.valueOf(i));//把1到n压入队列		}		while(!que.isEmpty())		{			qhead=que.poll();//弹出栈顶			//System.out.println("弹出栈顶----"+qhead);			for(int i=1;i<=n;i++)			{				//如果u中有存在的就continue				if(qhead.contains(String.valueOf(i)))				{					continue;//直接进入下一轮				}				u=String.valueOf(qhead)+String.valueOf(i);				//System.out.println("栈顶+后续为"+String.valueOf(qhead)+"-"+String.valueOf(i));				if(u.length()==n)				{					//System.out.println("-------------------------找到长度为3的"+u);					System.out.println(u);					s++;				}				else				{					que.offer(String.valueOf(u));					//System.out.println("长度不为3入列"+u);				}			}		}		System.out.println("共生产："+s);	}			public static void main(String[] args) 	{		BFSpermulation bfs=new BFSpermulation();		int n=0;		Scanner scan=new Scanner(System.in);		n=scan.nextInt();		bfs.bfs(n);	}}3弹出栈顶----1栈顶+后续为1-2长度不为3入列12栈顶+后续为1-3长度不为3入列13弹出栈顶----2栈顶+后续为2-1长度不为3入列21栈顶+后续为2-3长度不为3入列23弹出栈顶----3栈顶+后续为3-1长度不为3入列31栈顶+后续为3-2长度不为3入列32弹出栈顶----12栈顶+后续为12-3-------------------------找到长度为3的123123弹出栈顶----13栈顶+后续为13-2-------------------------找到长度为3的132132弹出栈顶----21栈顶+后续为21-3-------------------------找到长度为3的213213弹出栈顶----23栈顶+后续为23-1-------------------------找到长度为3的231231弹出栈顶----31栈顶+后续为31-2-------------------------找到长度为3的312312弹出栈顶----32栈顶+后续为32-1-------------------------找到长度为3的321321共生产：6
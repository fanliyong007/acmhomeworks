import java.util.Scanner;


public class DFSpermulation 
{
	int n=0;
	int[] a=new int[10];
	int[] b=new int[10];
	
	public void dfs(int step)//当前在第几个位置
	{
		
		if(step==n+1)//前n个数字已经放好
		{
			for(int i=1;i<=n;i++)
			{
				System.out.print(a[i]);
			}
			System.out.println();
			return;
		}
		//每次都从1-n 逐步尝试
		for(int i=1;i<=n;i++)
		{
			if(b[i]==0)//这个数字是否用过
			{
				a[step]=i;//没用过，这个位置就放i
				b[i]=1;//标示i已经被用过，防止再用
				dfs(step+1);//放好这个数字后，下一个数字，展开是一棵树
				b[i]=0;//回溯，当满足一种全排列后，下一个尝试			
			}
		}
		return;
	}
	
	public static void main(String[] args) 
	{
		DFSpermulation dfs=new DFSpermulation();
		int n=0;
		Scanner scan=new Scanner(System.in);
		n=scan.nextInt();
		dfs.n=n;
		dfs.dfs(1);

	}

}

3
------step=1
发现b[1]==0,可以存放,a[1]=1 标记为1，递归step+1=2
------step=2
发现b[2]==0,可以存放,a[2]=2 标记为1，递归step+1=3
------step=3
发现b[3]==0,可以存放,a[3]=3 标记为1，递归step+1=4
------step=4
step=4 找到全部排列打印：
123
回退--------------------------b[3]
回退--------------------------b[2]
发现b[3]==0,可以存放,a[2]=3 标记为1，递归step+1=3
------step=3
发现b[2]==0,可以存放,a[3]=2 标记为1，递归step+1=4
------step=4
step=4 找到全部排列打印：
132
回退--------------------------b[2]
回退--------------------------b[3]
回退--------------------------b[1]
发现b[2]==0,可以存放,a[1]=2 标记为1，递归step+1=2
------step=2
发现b[1]==0,可以存放,a[2]=1 标记为1，递归step+1=3
------step=3
发现b[3]==0,可以存放,a[3]=3 标记为1，递归step+1=4
------step=4
step=4 找到全部排列打印：
213
回退--------------------------b[3]
回退--------------------------b[1]
发现b[3]==0,可以存放,a[2]=3 标记为1，递归step+1=3
------step=3
发现b[1]==0,可以存放,a[3]=1 标记为1，递归step+1=4
------step=4
step=4 找到全部排列打印：
231
回退--------------------------b[1]
回退--------------------------b[3]
回退--------------------------b[2]
发现b[3]==0,可以存放,a[1]=3 标记为1，递归step+1=2
------step=2
发现b[1]==0,可以存放,a[2]=1 标记为1，递归step+1=3
------step=3
发现b[2]==0,可以存放,a[3]=2 标记为1，递归step+1=4
------step=4
step=4 找到全部排列打印：
312
回退--------------------------b[2]
回退--------------------------b[1]
发现b[2]==0,可以存放,a[2]=2 标记为1，递归step+1=3
------step=3
发现b[1]==0,可以存放,a[3]=1 标记为1，递归step+1=4
------step=4
step=4 找到全部排列打印：
321
回退--------------------------b[1]
回退--------------------------b[2]
回退--------------------------b[3]


4
1234
1243
1324
1342
1423
1432
2134
2143
2314
2341
2413
2431
3124
3142
3214
3241
3412
3421
4123
4132
4213
4231
4312
4321
共找到24

4
1234
1243
1324
1342
1423
1432
2134
2143
2314
2341
2413
2431
3124
3142
3214
3241
3412
3421
4123
4132
4213
4231
4312
4321
共生产：24

干净的BFS

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;


public class BFSpermulation 
{
	//offer(1),poll(),isEmpey();
	Queue<String> que=new LinkedList<String>();

	public void bfs(int n)
	{
		String qhead="";//队列的首
		int s=0;//产生的记录个数
		String u="";//记录产生的排列
		for(int i=1;i<=n;i++)
		{
			que.offer(String.valueOf(i));
		}
		
		while(!que.isEmpty())
		{
			qhead=que.poll();//弹出栈顶
			//System.out.println("弹出栈顶----"+qhead);
			
			for(int i=1;i<=n;i++)
			{
				//如果u中有存在的就continue
				if(qhead.contains(String.valueOf(i)))
				{
					continue;//直接进入下一轮
				}
				u=String.valueOf(qhead)+String.valueOf(i);
				//System.out.println("栈顶+后续为"+String.valueOf(qhead)+"-"+String.valueOf(i));
				if(u.length()==n)
				{
					//System.out.println("-------------------------找到长度为3的"+u);
					System.out.println(u);
					s++;
				}
				else
				{
					que.offer(String.valueOf(u));
					//System.out.println("长度不为3入列"+u);
				}
			}
		}
		System.out.println("共生产："+s);
	}
	
	
	public static void main(String[] args) 
	{
		BFSpermulation bfs=new BFSpermulation();
		int n=0;
		Scanner scan=new Scanner(System.in);
		n=scan.nextInt();
		bfs.bfs(n);

	}

}


3
弹出栈顶----1
栈顶+后续为1-2
长度不为3入列12
栈顶+后续为1-3
长度不为3入列13
弹出栈顶----2
栈顶+后续为2-1
长度不为3入列21
栈顶+后续为2-3
长度不为3入列23
弹出栈顶----3
栈顶+后续为3-1
长度不为3入列31
栈顶+后续为3-2
长度不为3入列32
弹出栈顶----12
栈顶+后续为12-3
-------------------------找到长度为3的123
123
弹出栈顶----13
栈顶+后续为13-2
-------------------------找到长度为3的132
132
弹出栈顶----21
栈顶+后续为21-3
-------------------------找到长度为3的213
213
弹出栈顶----23
栈顶+后续为23-1
-------------------------找到长度为3的231
231
弹出栈顶----31
栈顶+后续为31-2
-------------------------找到长度为3的312
312
弹出栈顶----32
栈顶+后续为32-1
-------------------------找到长度为3的321
321
共生产：6



